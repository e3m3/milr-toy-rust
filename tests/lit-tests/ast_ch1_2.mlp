// RUN: @mlpc --ast --parse %s 2>&1 | @filecheck %s
// COM: See original source at 'https://mlir.llvm.org/docs/Tutorials/Toy/Ch-1/'

def main() {
  // Define a variable `a` with shape <2, 3>, initialized with the literal value.
  // The shape is inferred from the supplied literal.
  var a = [[1, 2, 3], [4, 5, 6]];

  // b is identical to a, the literal tensor is implicitly reshaped: defining new
  // variables is the way to reshape tensors (element count must match).
  var b<2, 3> = [1, 2, 3, 4, 5, 6];

  // transpose() and print() are the only builtin, the following will transpose
  // a and b, printing the results.
  print(transpose(a));
  print(transpose(b));
}

// CHECK:   AST:
// CHECK:   Module '[[PATH:.*]][[MOD:ast_ch1_2\.mlp]]':
// CHECK:     Proto 'main' @[[PATH]][[MOD]]:4:1
// CHECK:     Params: []
// CHECK:     Block {
// CHECK:       VarDecl: a<> @[[PATH]][[MOD]]:7:3
// CHECK:         Literal: <2,3>[ @[[PATH]][[MOD]]:7:11
// CHECK:           Literal: <3>[ @[[PATH]][[MOD]]:7:12
// CHECK:             1, 2, 3
// CHECK:           ] // Literal
// CHECK:           Literal: <3>[ @[[PATH]][[MOD]]:7:23
// CHECK:             4, 5, 6
// CHECK:           ] // Literal
// CHECK:         ] // Literal
// CHECK:       VarDecl: b<2,3> @[[PATH]][[MOD]]:11:3
// CHECK:         Literal: <6>[ @[[PATH]][[MOD]]:11:17
// CHECK:           1, 2, 3, 4, 5, 6
// CHECK:         ] // Literal
// CHECK:       Print: @[[PATH]][[MOD]]:15:3
// CHECK:         Transpose: @[[PATH]][[MOD]]:15:9
// CHECK:           Var: a @[[PATH]][[MOD]]:15:19
// CHECK:       Print: @[[PATH]][[MOD]]:16:3
// CHECK:         Transpose: @[[PATH]][[MOD]]:16:9
// CHECK:           Var: b @[[PATH]][[MOD]]:16:19
// CHECK:     } // Block
